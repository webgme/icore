/* globals define */
// jshint node: true

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Mon Aug 27 2018 12:44:24 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'q',
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    Q,
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    // Modify these as needed..
    const MAX_RUN_TIME = 5000;
    const START_PORT = 5555;
    const COMMAND = 'python';
    const SCRIPT_FILE = 'src/plugins/PyCoreExecutor/run_plugin.py';

    /**
     * Initializes a new instance of PythonBindings.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin PythonBindings.
     * @constructor
     */
    function PyCoreExecutor() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    PyCoreExecutor.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    PyCoreExecutor.prototype = Object.create(PluginBase.prototype);
    PyCoreExecutor.prototype.constructor = PyCoreExecutor;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(null|Error|string, plugin.PluginResult)} callback - the result callback
     */
    PyCoreExecutor.prototype.main = function (callback) {
        const CoreZMQ = require('webgme-bindings').CoreZMQ;
        const cp = require('child_process');
        const logger = this.logger;

        let timeoutId;

        const callScript = (program, scriptPath, port) => {
            let deferred = Q.defer(),
                options = {},
                args = [
                    scriptPath,
                    port,
                    `"${this.commitHash}"`,
                    `"${this.branchName}"`,
                    `"${this.core.getPath(this.activeNode)}"`,
                    `"${this.activeSelection.map(node => this.core.getPath(node)).join(',')}"`,
                    `"${this.namespace}"`,
                ];

            const childProc = cp.spawn(program, args, options);

            timeoutId = setTimeout(() => {
                childProc.kill('SIGTERM');
                deferred.reject(new Error(`Python plugin did not finish within ${MAX_RUN_TIME} ms.`));
            }, MAX_RUN_TIME);

            childProc.stdout.on('data', data => {
                // logger.info(data.toString());
                logger.debug(data.toString());
            });

            childProc.stderr.on('data', data => {
                logger.error(data.toString());
                this.sendNotification({
                    message: data.toString(),
                    severity: 'error',
                });
            });

            childProc.on('close', (code) => {
                if (code > 0) {
                    deferred.reject(new Error(`Python process failed with error.`));
                } else {
                    deferred.resolve();
                }
            });

            childProc.on('error', (err) => {
                deferred.reject(err);
            });

            return deferred.promise;
        };

        const corezmq = new CoreZMQ(this.project, this.core, this.logger, {port: START_PORT, plugin: this});
        corezmq.startServer()
            .then((port) => {
                logger.info(`zmq-server listening at port ${port}`);

                return callScript(COMMAND, SCRIPT_FILE, port);
            })
            .then(() => {
                clearTimeout(timeoutId);
                return corezmq.stopServer();
            })
            .then(() => {
                this.result.setSuccess(true);
                callback(null, this.result);
            })
            .catch((err) => {
                this.logger.error(err.stack);
                clearTimeout(timeoutId);
                corezmq.stopServer()
                    .finally(() => {
                        // Result success is false at invocation.
                        callback(err, this.result);
                    });
            });
    };

    return PyCoreExecutor;
});
