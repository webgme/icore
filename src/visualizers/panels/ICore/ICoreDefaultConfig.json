{
  "templates": {
    "coreTraverse": {
      "displayName": "Traverse Model",
      "description": "Illustrates how to use core.traverse to visit each node in a sub-tree.",
      "script": "function (callback) {\n   var activeNode = this.activeNode,\n      core = this.core,\n      logger = this.logger;\n\n  function atNode(node, done) {\n    try {\n      var metaNode = core.getBaseType(node),\n          name = core.getAttribute(node, 'name'),\n          path = core.getPath(node),\n          metaType;\n\n      if (metaNode) {\n        metaType = core.getAttribute(metaNode, 'name');\n      } else {\n        // The root-node does not have a meta node.\n        metaType = 'undefined';\n      }\n\n      logger.info('[', path, '] - ', name, 'is of type', metaType); \n      done();\n    } catch (err) {\n      done(err);\n    }\n  }\n\n  core.traverse(activeNode, null, atNode, callback);\n}",
      "default": false
    },
    "blobClient": {
      "displayName": "BlobClient - store and return files",
      "description": "Illustrates how to use the blob-client and link to the artifacts in the result.",
      "script": "function (callback) {\n   var self = this,\n      activeNode = this.activeNode,\n      core = this.core,\n      logger = this.logger,\n      blobClient = this.blobClient,\n      artifact;\n  \n  artifact = self.blobClient.createArtifact('MyArtifact');\n  \n  artifact.addFiles({\n      'hello.txt': 'Hello world!',\n      'dir/hello2.txt': 'Hello from folder!'\n    })\n    .then(function (fileMetadataHashes) {\n      // We can link to each individual file\n      self.logger.info('Added files to blob-storage', fileMetadataHashes);\n      self.result.addArtifact(fileMetadataHashes[0]);\n      self.result.addArtifact(fileMetadataHashes[1]);\n      // and/or save the full artifact and link to it (will be a zip file).\n      return artifact.save();\n    })\n    .then(function (artifactHash) {\n      self.result.addArtifact(artifactHash);\n      self.logger.info('Added complex artifact to blob-storage', artifactHash);\n      self.result.setSuccess(true);\n      // A plugin should always return with a result, in iCore it's optional and\n      // used only to display the plugin result dialog.\n      callback(null, self.result);\n    })\n    .catch(function (err) {\n      callback(err);\n    });\n}",
      "default": false
    },
    "activeNode": {
      "displayName": "Minimal",
      "description": "Minimal example logging the name of the active node.",
      "script": "function (callback) {\n   var activeNode = this.activeNode,\n      core = this.core,\n      logger = this.logger;\n  \n  logger.debug('path:', core.getPath(activeNode));\n  logger.info('name:', core.getAttribute(activeNode, 'name'));\n  logger.warn('pos :', core.getRegistry(activeNode, 'position'));\n  logger.error('guid:', core.getGuid(activeNode));\n  callback();\n}",
      "default": true
    },
    "meta": {
      "displayName": "Meta nodes",
      "description": "Example showing how to get info about the meta-model.",
      "script": "function (callback) {\n   var activeNode = this.activeNode,\n      core = this.core,\n      logger = this.logger,\n      msg,\n      path2MetaNode,\n      metaNode,\n      baseNode,\n      metaName,\n      metaJson;\n  \n  // The 'plugin' is initialized with a map from name to the meta-node in this.META\n  // from the core we can get a map from unique paths to the meta-node.\n  path2MetaNode = core.getAllMetaNodes(activeNode);\n\n  for (metaName in this.META) {\n    logger.info('====== ', metaName, ' ======');\n    metaNode = this.META[metaName];\n    logger.info('name', core.getAttribute(metaNode, 'name'));\n    logger.info('path', core.getPath(metaNode));\n    baseNode = core.getBase(metaNode);\n\n    if (baseNode) {\n      logger.info('base', core.getAttribute(baseNode, 'name'), '[', core.getPath(baseNode), ']');\n    } else {\n      logger.info('base None');\n    }\n\n    logger.debug('Defines meta definitions :', JSON.stringify(core.getOwnJsonMeta(metaNode), null, 2));\n    metaJson = core.getJsonMeta(metaNode);\n    logger.debug('Resolved meta definitions:', JSON.stringify(metaJson, null, 2));\n\n    if (metaJson.children.items.length > 0) {\n      msg = 'Can contain (and their derived types): ';\n      metaJson.children.items.forEach(function (childPath) {\n        var childType = path2MetaNode[childPath];\n        // We check in case the meta is inconsisent.\n        if (childType) {\n          msg += '\"' + core.getAttribute(childType, 'name') + '\" ';\n        } else {\n          msg += '[' + childPath + '] ';\n        }\n      });\n      \n      logger.info(msg);\n    }\n\n    //TODO: Similar for pointers and sets, aspects and constraints..\n  }\n\n  callback();\n}",
      "default": false
    },
    "loadNodeMap": {
      "displayName": "Preload nodes",
      "description": "Example showing how to preload and retrieve a map of all nodes in a subtree.",
      "script": "function (callback) {\n  var self = this,\n    activeNode = this.activeNode,\n    core = this.core,\n    logger = this.logger;\n\n  this.loadNodeMap(activeNode)\n    .then(function (nodes) {\n      var path;\n      for (path in nodes) {\n        logger.debug('[', path, '] has name', core.getAttribute(nodes[path], 'name'));\n      }\n\n      logger.info('Total number of nodes in subtree:', Object.keys(nodes).length);\n\n      callback();\n    }).catch(function (err) {\n      self.logger.error(err.stack);\n      callback(err);\n    });\n}",
      "default": false
    }
  },
  "consoleWindow": {
    "verticalOrientation": true,
    "logLevel": "debug"
  },
  "codeEditor": {
    "autoSave": false,
    "autoSaveInterval": 2000,
    "scriptCodeAttribute": "scriptCode"
  },
  "defaultPluginId": ""
}